"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const extensionVariables_1 = require("../extensionVariables");
const localize_1 = require("../localize");
const nonNull_1 = require("../utils/nonNull");
const formatDeployLog_1 = require("./formatDeployLog");
function waitForDeploymentToComplete(client, kuduClient, pollingInterval = 5000) {
    return __awaiter(this, void 0, void 0, function* () {
        const alreadyDisplayedLogs = [];
        let nextTimeToDisplayWaitingLog = Date.now();
        let permanentId;
        let initialReceivedTime;
        let deployment;
        // tslint:disable-next-line:no-constant-condition
        while (true) {
            [deployment, permanentId, initialReceivedTime] = yield getLatestDeployment(kuduClient, permanentId, initialReceivedTime);
            if (deployment === undefined || !deployment.id) {
                throw new Error(localize_1.localize('failedToFindDeployment', 'Failed to get status of deployment.'));
            }
            let logEntries = [];
            try {
                logEntries = (yield kuduClient.deployment.getLogEntry(deployment.id));
            }
            catch (error) {
                // Swallow 404 errors for a deployment while its still in the "temp" phase
                // (We can't reliably get logs until the deployment has shifted to the "permanent" phase)
                // tslint:disable-next-line:no-unsafe-any
                if (!deployment.isTemp || !error || error.statusCode !== 404) {
                    throw error;
                }
            }
            const newLogEntries = logEntries.filter((newEntry) => !alreadyDisplayedLogs.some((oldId) => newEntry.id === oldId));
            if (newLogEntries.length === 0) {
                if (Date.now() > nextTimeToDisplayWaitingLog) {
                    extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, localize_1.localize('waitingForComand', 'Waiting for long running command to finish...')));
                    nextTimeToDisplayWaitingLog = Date.now() + 60 * 1000;
                }
            }
            else {
                for (const newEntry of newLogEntries) {
                    if (newEntry.id) {
                        alreadyDisplayedLogs.push(newEntry.id);
                        if (newEntry.message) {
                            extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, newEntry.message, newEntry.logTime));
                        }
                        if (newEntry.detailsUrl) {
                            const entryDetails = yield kuduClient.deployment.getLogEntryDetails(deployment.id, newEntry.id);
                            for (const entryDetail of entryDetails) {
                                if (entryDetail.message) {
                                    extensionVariables_1.ext.outputChannel.appendLine(formatDeployLog_1.formatDeployLog(client, entryDetail.message, entryDetail.logTime));
                                }
                            }
                        }
                    }
                }
            }
            if (deployment.complete) {
                if (deployment.isTemp) {
                    // If the deployment completed without making it to the "permanent" phase, it must have failed
                    throw new Error(localize_1.localize('deploymentFailed', 'Deployment to "{0}" failed. See output channel for more details.', client.fullName));
                }
                else {
                    return;
                }
            }
            else {
                yield new Promise((resolve) => { setTimeout(resolve, pollingInterval); });
            }
        }
    });
}
exports.waitForDeploymentToComplete = waitForDeploymentToComplete;
function getLatestDeployment(kuduClient, permanentId, initialReceivedTime) {
    return __awaiter(this, void 0, void 0, function* () {
        let deployment;
        if (permanentId) {
            // Use "permanentId" to find the deployment during its "permanent" phase
            deployment = yield kuduClient.deployment.getResult(permanentId);
        }
        else if (initialReceivedTime) {
            // Use "initialReceivedTime" to find the deployment during its "temp" phase
            deployment = (yield kuduClient.deployment.getDeployResults())
                // tslint:disable-next-line:no-non-null-assertion
                .filter((deployResult) => deployResult.receivedTime && deployResult.receivedTime >= initialReceivedTime)
                .sort((a, b) => nonNull_1.nonNullProp(b, 'receivedTime').valueOf() - nonNull_1.nonNullProp(a, 'receivedTime').valueOf())
                .shift();
            if (deployment && !deployment.isTemp) {
                // Make note of the id once the deplyoment has shifted to the "permanent" phase, so that we can use that to find the deployment going forward
                permanentId = deployment.id;
            }
        }
        else {
            // Use "latest" to get the deployment before we know the "initialReceivedTime" or "permanentId"
            deployment = (yield kuduClient.deployment.getResult('latest'));
            if (deployment && deployment.receivedTime) {
                // Make note of the initialReceivedTime, so that we can use that to find the deployment going forward
                initialReceivedTime = deployment.receivedTime;
            }
        }
        return [deployment, permanentId, initialReceivedTime];
    });
}
//# sourceMappingURL=waitForDeploymentToComplete.js.map